[2012/XX/XX - Version0.0.3 - リリース]
・-dbport追加
・-masterport追加
・-queryで指定するSQL内でAdapterから投入された直近のデータを条件として利用できる機能を追加
  利用イメージはSQL内のAdapterからのデータで置き換えたい箇所にカラム名を特定のフォーマット(%カラム名%)で
  指定するとその部分がSQL実行時には、Adapterからの直近のデータで置換されて実行される。
  1つのSQL内でいくつでも指定可能。

  指定及び、実行イメージは以下となる
   1.Adapterから以下のデータが来た場合
    Reply from 192.168.11.1: bytes=32 time=1ms TTL=64
   2.内部には以下のテーブル定義で自動的に格納される。
    ※DBテーブル内のデータを"カラム名:データ"のフォーマットで以下に表す   
     COLUMN0:Reply
     COLUMN1:from
     COLUMN2:192.168.11.1:
     COLUMN3:bytes=32
     COLUMN4:time=1ms
     COLUMN5:TTL=64
   3.以下のSQLを指定(Where句の指定の部分に%Column4%を指定
     -query "select * from pipe where to_number(column4) > to_number(%Column4%)"
   4.実際には以下のSQLが実行される
     select * from pipe where to_number(column4) > to_number('time=1ms')
   5.%Column4%の部分が実際にはAdapterからのデータの'time=1ms'に置換されている


・-trigger及び、-queryを複数個指定可能とした。
  指定方法は複数個-triggerや-queryを指定するのみ。
  先頭から-tirggerから実行され、指定した全ての条件をクリア後、-queryが同じように
  先頭から実行される。

・-easyqueyを追加
  SQLを直接記述せずに関数を呼び出し、SQLでの確認と同等のことを行う。
  現在利用可能な関数とその機能は以下
  [関数一覧]");
  'avg_over':特定のカラムの平均が指定値以上か調べる(対象Table名, 対象Column名, 条件指定の値)
  'avg_below':特定のカラムの平均が指定値以下か調べる(対象Table名, 対象Column名, 条件指定の値)
  'over_value':特定のカラムの最大値が指定値以上か調べる(対象Table名, 対象Column名, 条件指定の値)
  'below_value':特定のカラムの最小値が指定値以下か調べる(対象Table名, 対象Column名, 条件指定の値)
  'avg_more_over':特定のカラムの平均の指定倍以上の値が存在するか調べる(対象Table名, 対象Column名, 条件指定の値)
  [指定例]");
   -easyquery avg_over(pipe, column4, 3)
   ※内部で実際に実行されているSQLは-debug onで確認可能


サーバモードを追加
・従来のコマンドラインモードではなく完全なサーバモード
　外部からサーバを起動出来て、-trigger,-query,-eventの全てを指定できるモード
　サーバI/Fには、MessagePack-RPCを利用
　残りは全てスクリプト構文での指定を可能として、動的コンパイルによりデータ受信中にも
　全ての要素を変更可能とする。スクリプト構文にはJVMが持つ他言語の実行エンジンも対応する
　もちろんクラスのデプロイにより完全にStaticな状況もつくれることとする。
　一度の複数のStreamをさばけるように内部は完全な分散とする。


------------------------------------------------------------------------------------------------
[2012/03/24 - Version0.0.2 - リリース]
※今回のリリース機能は全て-helpでも確認できます。


■追加機能[1]
  Setsuna起動時にサーバモードで起動するオプションを追加

  以下の起動方法で起動することでサーバモードで起動し、従来のパイプではなく
  NetWork越しにデータを投入することが可能です。

  (事前準備)
  Setsunaのサーバモードは内部的にMessagePack-RPCのJava版を利用しています。
  そのため、起動するにはMessagePack-RPCとそれが依存するライブラリが必要になります。
  リリース時点で利用したライブラリを配布物のlibディレクトリ配下のmsgpackの下に全て同梱しています。
  ただ、最新の関連するライブラリを配布元から取得して利用することをおすすめします。

  [サーバ側の説明]
   (起動方法) !!注意!! 従来の-jar指定での利用はできません。
    java -classpath ./:./lib/msgpack/*:setsuna.jar setsuna.core.SetsunaMain -server true

    ※Linux想定 
    ※リリース物展開ディレクトリでの操作想定 
    ※従来のパイプ入力の場合は従来通りの起動方法です。(java -jar setsuna.jar)
   (利用する起動パラメータ
    ・-server   :trueを指定することで、サーバモードで起動します。
                 (例) -server true

    ・-bindaddr :サーバモードの起動時のサーバがバインドするアドレス
                 省略した場合0.0.0.0アドレスにバンドされることになる
                 (例) -bindaddr 192.168.1.1

    ・-bindport :サーバモードの起動時のサーバが待ち受けるポート番号
                 省略した場合10028で起動することになる
                 (例) -bindport 10222

   (説明)
    1."-server true"を指定することでサーバモードになりNWサーバ型になる。
      作成されるテーブル名指定(-stream)を省略すると"SERVER"というテーブル名でデータベース上に作成されます。
    2.データを投入する部分以外は従来と全て同じ利用方法ですが、-sep、-sept、-dstオプションは無効になります。
      カラム定義に関しては-column指定でサーバ起動時に決定するか、クライアント側から最初に送られたデータで自動作成されます。

  [クライアント側の説明]
   (サーバ側に定義されているメソッド)
    サーバ側のデータ投入に呼び出すメソッドは以下のようにサーバに定義されています。
    [定義メソッド]
     int next (String[] sendData)
      @引数  ：Setsunaに投入したい1レコードのデータColumn数分のデータの配列
      @戻り値：Setsuna側の登録結果 0=登録成功、-9=カラム定義と送られたデータ配列の数が合わないエラー、-9=サーバ内部エラー

   (サンプル実装)
    ./test/ServerClientSample配下のSetsunaServerModeClientSample.javaを参考にしてください。



■追加機能[2]
  Setsuna自身のエラー出力をファイルに出力できる機能を追加

  従来Setsunaは内部で発生したエラー出力も全てコンソールに出力されていたが、これをファイルに出力する機能です。
  起動オプションに以下を指定
  [オプション文字列]
   -errorlog
  [指定する値]
   ファイルパス
  [指定例]
   -errorlog "/var/log/setsuna_error.log"



■追加機能[3]
  デバッグモードの追加

  Adapter、Query、UserEventでどのようなインプットデータ、Trigger、Query、UserEventコマンドを扱ったかを
  標準出力にプリントアウトする機能を追加

  それぞれの箇所で以下のようなフォーマットで出力される。
  [Adapter]
   パイプ入力時:"Debug : Fri Mar 23 23:40:53 JST 2012 - - Pipe Input=[入力されたデータ]"
   Serverモード時:"Debug : Fri Mar 23 23:37:20 JST 2012 - - Server Input=[[0]="送信されたデータ配列の1番目のデータ",[1]="送信されたデータ配列の2番目のデータ"・・・以降同じ]"
  [Query]
   -trigger : "Debug : Fri Mar 23 23:45:06 JST 2012 - - -trigger Query=[入力データ 検証記号 ユーザ指定値]"
              (例) Debug : Fri Mar 23 23:45:06 JST 2012 - - -trigger Query=[=32 > 100]
   -query : "Debug : Fri Mar 23 23:47:35 JST 2012 - - -query SQL=[指定したSQL文]"
  [UserEvent]
   -event : "Debug : Fri Mar 23 23:52:58 JST 2012 - - -event=[実行されたコマンド文字列]"
   -eventquery: "Debug : Fri Mar 23 23:54:01 JST 2012 - - -eventquery=[実行されたSQL]"

  デバッグモードには2種類モードが存在し、
  1つはデバッグ文字列とSetsunaの標準出力(データ文字列など)混在モードと
  デバッグ文字列のみ出力するモードがある。

  起動オプションに以下を指定
  [オプション文字列]
   -debug
  [指定する値]
   on       (混在)
   only     (デバッグ文字のみ)
  [指定例]
   -debug on
   -debug only



■追加機能[4]
  入力データ読み込み開始位置の設定機能

  標準入力モード時や、サーバモード時に送り込まれたデータを指定されたデータ数;
  スキップ(読み込まない)してから初めて内部DBへの格納を開始する機能

  利用イメージは読み込ませるデータの最初のレコードに空白や、本来読み込みたい
  データと異なるフォーマットが存在した場合に利用する。
  このオプションを利用する場合は必ず-columnオプションも設定する必要がある
  これはデータを格納するテーブル定義を作成する必要があるためである

  起動オプションに以下を指定
  [オプション文字列]
   -offset
  [指定する値]
   数値 (取り込みを開始したいレコード数を指定)
  [指定例]
   -offset 3 -column "col1 col2 col3"
   ※上記の場合、パイプなどで送り込まれたデータの3レコード目から初めて取り込まれだす。
     ただし、-column指定を必ず設定する必要がある



■追加機能[5]
  カラム定義と異なるフォーマットのデータが入力された場合に無視して取り込まない機能

  従来はカラム定義と異なるデータが入力された場合、正しく取り込まれずExceptionを
  発行していたが、この機能を利用することでそういった入力データをスキップするようになる

  例えばカラム定義や、Setsunaが取り込んだ1レコード目が以下のフォーマットの場合
  ┌────────────────────┐
  │ "XXXXX YYYYY ZZZZZ"                    │
  └────────────────────┘
  カラムは3つとなる。この状態で入力データの2レコード目以降に以下のようなデータが入力されると
  ┌────────────────────┐
  │ "AAAAA BBBBB"                          │
  └────────────────────┘
  1レコード目のカラム数に対して異なるためExceptionが発行されSetsunaが終了していた。
  こういった場合に本機能を使うと異なるデータは取り込まなくなる。

  起動オプションに以下を指定
  [オプション文字列]
   -skiperror
  [指定する値]
   true
  [指定例]
   -skiperror true

